<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WebsocketClientImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">io.github.binance:binance-futures-connector-java</a> &gt; <a href="index.source.html" class="el_package">com.binance.connector.futures.client.impl</a> &gt; <span class="el_source">WebsocketClientImpl.java</span></div><h1>WebsocketClientImpl.java</h1><pre class="source lang-java linenums">package com.binance.connector.futures.client.impl;

import com.binance.connector.futures.client.utils.HttpClientSingleton;
import com.binance.connector.futures.client.utils.RequestBuilder;
import com.binance.connector.futures.client.utils.UrlBuilder;
import com.binance.connector.futures.client.utils.WebSocketCallback;
import com.binance.connector.futures.client.utils.WebSocketConnection;
import com.binance.connector.futures.client.utils.ParameterChecker;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import okhttp3.Request;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * &lt;h2&gt;Futures Websocket Streams&lt;/h2&gt;
 * All stream endpoints under the
 * &lt;a href=&quot;https://binance-docs.github.io/apidocs/futures/en/#websocket-market-streams&quot;&gt; USDⓈ-M Websocket Market Streams&lt;/a&gt; and
 * &lt;a href=&quot;https://binance-docs.github.io/apidocs/delivery/en/#websocket-market-streams&quot;&gt; COIN-M Websocket Market Streams&lt;/a&gt; and
 * &lt;a href=&quot;https://binance-docs.github.io/apidocs/futures/en/#user-data-streams&quot;&gt; USDⓈ-M User Data Streams&lt;/a&gt; and
 * &lt;a href=&quot;https://binance-docs.github.io/apidocs/delivery/en/#user-data-streams&quot;&gt; COIN-M User Data Streams&lt;/a&gt;
 * section of the API documentation will be implemented in this class.
 * &lt;br&gt;
 * Response will be returned as callback.
 */
public abstract class WebsocketClientImpl {
    private final String baseUrl;
<span class="fc" id="L30">    private final Map&lt;Integer, WebSocketConnection&gt; connections = new HashMap&lt;&gt;();</span>
<span class="fc" id="L31">    private final WebSocketCallback noopCallback = msg -&gt; {</span>
<span class="fc" id="L32">    };</span>
<span class="fc" id="L33">    private static final Logger logger = LoggerFactory.getLogger(WebsocketClientImpl.class);</span>

<span class="fc" id="L35">    public WebsocketClientImpl(String baseUrl) {</span>
<span class="fc" id="L36">        this.baseUrl = baseUrl;</span>
<span class="fc" id="L37">    }</span>

    public WebSocketCallback getNoopCallback() {
<span class="fc" id="L40">        return this.noopCallback;</span>
    }

    public String getBaseUrl() {
<span class="fc" id="L44">        return this.baseUrl;</span>
    }

    /**
     * The Aggregate Trade Streams push market trade information that is aggregated for fills with same price and taking side every 100 milliseconds.
     * Only market trades will be aggregated, which means the insurance fund trades and ADL trades won't be aggregated.
     * &lt;br&gt;&lt;br&gt;
     * &amp;lt;symbol&amp;gt;@aggTrade
     * &lt;br&gt;&lt;br&gt;
     * Update Speed: 100ms
     *
     * @param symbol trading symbol
     * @param onMessageCallback onMessageCallback
     * @return int - Connection ID
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/futures/en/#aggregate-trade-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/futures/en/#aggregate-trade-streams&lt;/a&gt;
     */
    public int aggTradeStream(String symbol, WebSocketCallback onMessageCallback) {
<span class="nc" id="L62">        ParameterChecker.checkParameterType(symbol, String.class, &quot;symbol&quot;);</span>
<span class="nc" id="L63">        return aggTradeStream(symbol, noopCallback,  onMessageCallback, noopCallback, noopCallback);</span>
    }

    /**
     * Same as {@link #aggTradeStream(String, WebSocketCallback)} plus accepts callbacks for all major websocket connection events.
     *
     * @param symbol trading symbol
     * @param onOpenCallback onOpenCallback
     * @param onMessageCallback onMessageCallback
     * @param onClosingCallback onClosingCallback
     * @param onFailureCallback onFailureCallback
     * @return int - Connection ID
     */
    public int aggTradeStream(String symbol, WebSocketCallback onOpenCallback, WebSocketCallback onMessageCallback, WebSocketCallback onClosingCallback, WebSocketCallback onFailureCallback) {
<span class="nc" id="L77">        ParameterChecker.checkParameterType(symbol, String.class, &quot;symbol&quot;);</span>
<span class="nc" id="L78">        Request request = RequestBuilder.buildWebsocketRequest(String.format(&quot;%s/ws/%s@aggTrade&quot;, baseUrl, symbol.toLowerCase()));</span>
<span class="nc" id="L79">        return createConnection(onOpenCallback, onMessageCallback, onClosingCallback, onFailureCallback, request);</span>
    }

    /**
     * Mark price and funding rate for a single symbol pushed every 3 seconds or every second.
     * &lt;br&gt;&lt;br&gt;
     * &amp;lt;symbol&amp;gt;@markPrice or &amp;lt;symbol&amp;gt;@markPrice@1s
     * &lt;br&gt;&lt;br&gt;
     * Update Speed: 3000ms or 1000ms
     *
     * @param symbol trading symbol
     * @param speed speed in seconds, can be 1 or 3
     * @param onMessageCallback onMessageCallback
     * @return int - Connection ID
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/futures/en/#mark-price-stream&quot;&gt;
     * https://binance-docs.github.io/apidocs/futures/en/#mark-price-stream&lt;/a&gt;
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/delivery/en/#mark-price-stream&quot;&gt;
     * https://binance-docs.github.io/apidocs/delivery/en/#mark-price-stream&lt;/a&gt;
     */
    public int markPriceStream(String symbol, int speed, WebSocketCallback onMessageCallback) {
<span class="fc" id="L99">        ParameterChecker.checkParameterType(symbol, String.class, &quot;symbol&quot;);</span>
<span class="fc" id="L100">        return markPriceStream(symbol, speed, noopCallback, onMessageCallback, noopCallback, noopCallback);</span>
    }

    /**
     * Same as {@link #markPriceStream(String, int, WebSocketCallback)} plus accepts callbacks for all major websocket connection events.
     *
     * @param symbol trading symbol
     * @param speed speed in seconds, can be 1 or 3
     * @param onOpenCallback onOpenCallback
     * @param onMessageCallback onMessageCallback
     * @param onClosingCallback onClosingCallback
     * @param onFailureCallback onFailureCallback
     * @return int - Connection ID
     */
    public int markPriceStream(String symbol, int speed, WebSocketCallback onOpenCallback, WebSocketCallback onMessageCallback, WebSocketCallback onClosingCallback, WebSocketCallback onFailureCallback) {
<span class="fc" id="L115">        Request request = null;</span>
<span class="fc" id="L116">        final int defaultSpeed = 3;</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">        if (speed == defaultSpeed) {</span>
<span class="fc" id="L118">            String reqStr = String.format(&quot;%s/ws/%s@markPrice&quot;, baseUrl, symbol.toLowerCase());</span>
<span class="fc" id="L119">            request = RequestBuilder.buildWebsocketRequest(reqStr);</span>
<span class="fc" id="L120">        }</span>
        else {
<span class="nc" id="L122">            String reqStr = String.format(&quot;%s/ws/%s@markPrice@%ss&quot;, baseUrl, symbol.toLowerCase(), speed);</span>
<span class="nc" id="L123">            request = RequestBuilder.buildWebsocketRequest(reqStr);</span>

        }
<span class="fc" id="L126">        return createConnection(onOpenCallback, onMessageCallback, onClosingCallback, onFailureCallback, request);</span>
    }

    /**
     * The Kline/Candlestick Stream push updates to the current klines/candlestick every 250 milliseconds (if existing).
     * &lt;br&gt;&lt;br&gt;
     * &amp;lt;symbol&amp;gt;@kline_&amp;lt;interval&amp;gt;
     * &lt;br&gt;&lt;br&gt;
     * Update Speed: 250ms
     *
     * @param symbol trading symbol
     * @param interval kline interval - 1m 3m 5m 15m 30m 1h 2h 4h 6h 8h 12h 1d 3d 1w 1M
     * @param onMessageCallback onMessageCallback
     * @return int - Connection ID
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/futures/en/#kline-candlestick-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/futures/en/#kline-candlestick-streams&lt;/a&gt;
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/delivery/en/#kline-candlestick-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/delivery/en/#kline-candlestick-streams&lt;/a&gt;
     */
    public int klineStream(String symbol, String interval, WebSocketCallback onMessageCallback) {
<span class="nc" id="L146">        ParameterChecker.checkParameterType(symbol, String.class, &quot;symbol&quot;);</span>
<span class="nc" id="L147">        return klineStream(symbol, interval, noopCallback, onMessageCallback, noopCallback, noopCallback);</span>
    }

    /**
     * Same as {@link #klineStream(String, String, WebSocketCallback)} plus accepts callbacks for all major websocket connection events.
     *
     * @param symbol trading symbol
     * @param interval kline interval - 1m 3m 5m 15m 30m 1h 2h 4h 6h 8h 12h 1d 3d 1w 1M
     * @param onOpenCallback onOpenCallback
     * @param onMessageCallback onMessageCallback
     * @param onClosingCallback onClosingCallback
     * @param onFailureCallback onFailureCallback
     * @return int - Connection ID
     */
    public int klineStream(String symbol, String interval, WebSocketCallback onOpenCallback, WebSocketCallback onMessageCallback, WebSocketCallback onClosingCallback, WebSocketCallback onFailureCallback) {
<span class="nc" id="L162">        ParameterChecker.checkParameterType(symbol, String.class, &quot;symbol&quot;);</span>
<span class="nc" id="L163">        Request request = RequestBuilder.buildWebsocketRequest(String.format(&quot;%s/ws/%s@kline_%s&quot;, baseUrl, symbol.toLowerCase(), interval));</span>
<span class="nc" id="L164">        return createConnection(onOpenCallback, onMessageCallback, onClosingCallback, onFailureCallback, request);</span>
    }

    /**
     * The Kline/Candlestick Stream push updates to the current klines/candlestick every 250 milliseconds (if existing). Contract Types are: perpetual, current_quarter, next_quarter
     * &lt;br&gt;&lt;br&gt;
     *  &amp;lt;pair&amp;gt;_&amp;lt;contractType&amp;gt;@continuousKline_&amp;lt;interval&amp;gt;
     * &lt;br&gt;&lt;br&gt;
     * Update Speed: 250ms
     *
     * @param pair trading pair
     * @param contractType perpetual, current_quarter, next_quarter
     * @param interval kline interval - 1m 3m 5m 15m 30m 1h 2h 4h 6h 8h 12h 1d 3d 1w 1M
     * @param onMessageCallback onMessageCallback
     * @return int - Connection ID
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/delivery/en/#continuous-contract-kline-candlestick-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/delivery/en/#continuous-contract-kline-candlestick-streams&lt;/a&gt;
     */
    public int continuousKlineStream(String pair, String contractType, String interval, WebSocketCallback onMessageCallback) {
<span class="nc" id="L183">        ParameterChecker.checkParameterType(pair, String.class, &quot;pair&quot;);</span>
<span class="nc" id="L184">        return continuousKlineStream(pair, contractType, interval, noopCallback, onMessageCallback, noopCallback, noopCallback);</span>
    }

    /**
     * Same as {@link #continuousKlineStream(String, String, String, WebSocketCallback)} plus accepts callbacks for all major websocket connection events.
     *
     * @param pair trading pair
     * @param interval kline interval - 1m 3m 5m 15m 30m 1h 2h 4h 6h 8h 12h 1d 3d 1w 1M
     * @param contractType perpetual, current_quarter, next_quarter
     * @param onOpenCallback onOpenCallback
     * @param onMessageCallback onMessageCallback
     * @param onClosingCallback onClosingCallback
     * @param onFailureCallback onFailureCallback
     * @return int - Connection ID
     */
    public int continuousKlineStream(String pair, String contractType, String interval, WebSocketCallback onOpenCallback, WebSocketCallback onMessageCallback, WebSocketCallback onClosingCallback, WebSocketCallback onFailureCallback) {
<span class="nc" id="L200">        ParameterChecker.checkParameterType(pair, String.class, &quot;pair&quot;);</span>
<span class="nc" id="L201">        ParameterChecker.checkParameterType(contractType, String.class, &quot;contractType&quot;);</span>
<span class="nc" id="L202">        ParameterChecker.checkParameterType(interval, String.class, &quot;interval&quot;);</span>

<span class="nc" id="L204">        Request request = RequestBuilder.buildWebsocketRequest(String.format(&quot;%s/ws/%s_%s@continuousKline_%s&quot;, baseUrl, pair.toLowerCase(), contractType, interval));</span>
<span class="nc" id="L205">        return createConnection(onOpenCallback, onMessageCallback, onClosingCallback, onFailureCallback, request);</span>
    }

    /**
     * 24hr rolling window mini-ticker statistics.
     * These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs.
     * &lt;br&gt;&lt;br&gt;
     * &amp;lt;symbol&amp;gt;@miniTicker
     * &lt;br&gt;&lt;br&gt;
     * Update Speed: 500ms
     *
     * @param symbol trading symbol
     * @param onMessageCallback onMessageCallback
     * @return int - Connection ID
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/futures/en/#individual-symbol-mini-ticker-stream&quot;&gt;
     * https://binance-docs.github.io/apidocs/futures/en/#individual-symbol-mini-ticker-stream&lt;/a&gt;
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/delivery/en/#individual-symbol-mini-ticker-stream&quot;&gt;
     * https://binance-docs.github.io/apidocs/delivery/en/#individual-symbol-mini-ticker-stream&lt;/a&gt;
     */
    public int miniTickerStream(String symbol, WebSocketCallback onMessageCallback) {
<span class="nc" id="L225">        ParameterChecker.checkParameterType(symbol, String.class, &quot;symbol&quot;);</span>
<span class="nc" id="L226">        return miniTickerStream(symbol, noopCallback, onMessageCallback, noopCallback, noopCallback);</span>
    }

    /**
     * Same as {@link #miniTickerStream(String, WebSocketCallback)} plus accepts callbacks for all major websocket connection events.
     *
     * @param symbol trading symbol
     * @param onOpenCallback onOpenCallback
     * @param onMessageCallback onMessageCallback
     * @param onClosingCallback onClosingCallback
     * @param onFailureCallback onFailureCallback
     * @return int - Connection ID
     */
    public int miniTickerStream(String symbol, WebSocketCallback onOpenCallback, WebSocketCallback onMessageCallback, WebSocketCallback onClosingCallback, WebSocketCallback onFailureCallback) {
<span class="nc" id="L240">        ParameterChecker.checkParameterType(symbol, String.class, &quot;symbol&quot;);</span>
<span class="nc" id="L241">        Request request = RequestBuilder.buildWebsocketRequest(String.format(&quot;%s/ws/%s@miniTicker&quot;, baseUrl, symbol.toLowerCase()));</span>
<span class="nc" id="L242">        return createConnection(onOpenCallback, onMessageCallback, onClosingCallback, onFailureCallback, request);</span>
    }

    /**
     * 24hr rolling window mini-ticker statistics for all symbols that changed in an array.
     * These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs.
     * Note that only tickers that have changed will be present in the array.
     * &lt;br&gt;&lt;br&gt;
     * !miniTicker@arr
     * &lt;br&gt;&lt;br&gt;
     * Update Speed: 1000ms
     *
     * @param onMessageCallback onMessageCallback
     * @return int - Connection ID
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/futures/en/#all-market-mini-tickers-stream&quot;&gt;
     * https://binance-docs.github.io/apidocs/futures/en/#all-market-mini-tickers-stream&lt;/a&gt;
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/delivery/en/#all-market-mini-tickers-stream&quot;&gt;
     * https://binance-docs.github.io/apidocs/delivery/en/#all-market-mini-tickers-stream&lt;/a&gt;
     */
    public int allMiniTickerStream(WebSocketCallback onMessageCallback) {
<span class="nc" id="L262">        return allMiniTickerStream(noopCallback, onMessageCallback, noopCallback, noopCallback);</span>
    }

    /**
     * Same as {@link #allMiniTickerStream(WebSocketCallback)} plus accepts callbacks for all major websocket connection events.
     *
     * @param onOpenCallback onOpenCallback
     * @param onMessageCallback onMessageCallback
     * @param onClosingCallback onClosingCallback
     * @param onFailureCallback onFailureCallback
     * @return int - Connection ID
     */
    public int allMiniTickerStream(WebSocketCallback onOpenCallback, WebSocketCallback onMessageCallback, WebSocketCallback onClosingCallback, WebSocketCallback onFailureCallback) {
<span class="nc" id="L275">        Request request = RequestBuilder.buildWebsocketRequest(String.format(&quot;%s/ws/!miniTicker@arr&quot;, baseUrl));</span>
<span class="nc" id="L276">        return createConnection(onOpenCallback, onMessageCallback, onClosingCallback, onFailureCallback, request);</span>
    }

    /**
     * 24hr rolling window ticker statistics for a single symbol.
     * These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs.
     * &lt;br&gt;&lt;br&gt;
     * &amp;lt;symbol&amp;gt;@ticker
     * &lt;br&gt;&lt;br&gt;
     * Update Speed: 500ms
     *
     * @param symbol trading symbol
     * @param onMessageCallback onMessageCallback
     * @return int - Connection ID
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/futures/en/#individual-symbol-ticker-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/futures/en/#individual-symbol-ticker-streams&lt;/a&gt;
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/delivery/en/#individual-symbol-ticker-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/delivery/en/#individual-symbol-ticker-streams&lt;/a&gt;
     */
    public int symbolTicker(String symbol, WebSocketCallback onMessageCallback) {
<span class="nc" id="L296">        ParameterChecker.checkParameterType(symbol, String.class, &quot;symbol&quot;);</span>
<span class="nc" id="L297">        return symbolTicker(symbol, noopCallback, onMessageCallback, noopCallback, noopCallback);</span>
    }

    /**
     * Same as {@link #symbolTicker(String, WebSocketCallback)} plus accepts callbacks for all major websocket connection events.
     *
     * @param symbol trading symbol
     * @param onOpenCallback onOpenCallback
     * @param onMessageCallback onMessageCallback
     * @param onClosingCallback onClosingCallback
     * @param onFailureCallback onFailureCallback
     * @return int - Connection ID
     */
    public int symbolTicker(String symbol, WebSocketCallback onOpenCallback, WebSocketCallback onMessageCallback, WebSocketCallback onClosingCallback, WebSocketCallback onFailureCallback) {
<span class="nc" id="L311">        ParameterChecker.checkParameterType(symbol, String.class, &quot;symbol&quot;);</span>
<span class="nc" id="L312">        Request request = RequestBuilder.buildWebsocketRequest(String.format(&quot;%s/ws/%s@ticker&quot;, baseUrl, symbol.toLowerCase()));</span>
<span class="nc" id="L313">        return createConnection(onOpenCallback, onMessageCallback, onClosingCallback, onFailureCallback, request);</span>
    }

    /**
     * 24hr rolling window ticker statistics for all symbols.
     * These are NOT the statistics of the UTC day, but a 24hr rolling window from requestTime to 24hrs before.
     * Note that only tickers that have changed will be present in the array.
     * &lt;br&gt;&lt;br&gt;
     * !ticker@arr
     * &lt;br&gt;&lt;br&gt;
     * Update Speed: 1000ms
     *
     * @param onMessageCallback onMessageCallback
     * @return int - Connection ID
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/futures/en/#all-market-tickers-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/futures/en/#all-market-tickers-streams&lt;/a&gt;
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/delivery/en/#all-market-tickers-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/delivery/en/#all-market-tickers-streams&lt;/a&gt;
     */
    public int allTickerStream(WebSocketCallback onMessageCallback) {
<span class="nc" id="L333">        return allTickerStream(noopCallback, onMessageCallback, noopCallback, noopCallback);</span>
    }

    /**
     * Same as {@link #allTickerStream(WebSocketCallback)} plus accepts callbacks for all major websocket connection events.
     *
     * @param onOpenCallback onOpenCallback
     * @param onMessageCallback onMessageCallback
     * @param onClosingCallback onClosingCallback
     * @param onFailureCallback onFailureCallback
     * @return int - Connection ID
     */
    public int allTickerStream(WebSocketCallback onOpenCallback, WebSocketCallback onMessageCallback, WebSocketCallback onClosingCallback, WebSocketCallback onFailureCallback) {
<span class="nc" id="L346">        Request request = RequestBuilder.buildWebsocketRequest(String.format(&quot;%s/ws/!ticker@arr&quot;, baseUrl));</span>
<span class="nc" id="L347">        return createConnection(onOpenCallback, onMessageCallback, onClosingCallback, onFailureCallback, request);</span>
    }

     /**
     * Pushes any update to the best bid or ask's price or quantity in real-time for a specified symbol.
     * &lt;br&gt;&lt;br&gt;
     * &amp;lt;symbol&amp;gt;@bookTicker
     * &lt;br&gt;&lt;br&gt;
     * Update Speed: Real-time
     *
     * @param symbol trading symbol
     * @param onMessageCallback onMessageCallback
     * @return int - Connection ID
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/futures/en/#individual-symbol-book-ticker-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/futures/en/#individual-symbol-book-ticker-streams&lt;/a&gt;
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/delivery/en/#individual-symbol-book-ticker-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/delivery/en/#individual-symbol-book-ticker-streams&lt;/a&gt;
     */
    public int bookTicker(String symbol, WebSocketCallback onMessageCallback) {
<span class="nc" id="L366">        ParameterChecker.checkParameterType(symbol, String.class, &quot;symbol&quot;);</span>
<span class="nc" id="L367">        return bookTicker(symbol, noopCallback, onMessageCallback, noopCallback, noopCallback);</span>
    }

    /**
     * Same as {@link #bookTicker(String, WebSocketCallback)} plus accepts callbacks for all major websocket connection events.
     *
     * @param symbol trading symbol
     * @param onOpenCallback onOpenCallback
     * @param onMessageCallback onMessageCallback
     * @param onClosingCallback onClosingCallback
     * @param onFailureCallback onFailureCallback
     * @return int - Connection ID
     */
    public int bookTicker(String symbol, WebSocketCallback onOpenCallback, WebSocketCallback onMessageCallback, WebSocketCallback onClosingCallback, WebSocketCallback onFailureCallback) {
<span class="nc" id="L381">        ParameterChecker.checkParameterType(symbol, String.class, &quot;symbol&quot;);</span>
<span class="nc" id="L382">        Request request = RequestBuilder.buildWebsocketRequest(String.format(&quot;%s/ws/%s@bookTicker&quot;, baseUrl, symbol.toLowerCase()));</span>
<span class="nc" id="L383">        return createConnection(onOpenCallback, onMessageCallback, onClosingCallback, onFailureCallback, request);</span>
    }

    /**
     * Pushes any update to the best bid or ask's price or quantity in real-time for all symbols.
     * &lt;br&gt;&lt;br&gt;
     * !bookTicker
     * &lt;br&gt;&lt;br&gt;
     * Update Speed: Real-time
     *
     * @param onMessageCallback onMessageCallback
     * @return int - Connection ID
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/futures/en/#all-book-tickers-stream&quot;&gt;
     * https://binance-docs.github.io/apidocs/futures/en/#all-book-tickers-stream&lt;/a&gt;
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/delivery/en/#all-book-tickers-stream&quot;&gt;
     * https://binance-docs.github.io/apidocs/delivery/en/#all-book-tickers-stream&lt;/a&gt;
     */
    public int allBookTickerStream(WebSocketCallback onMessageCallback) {
<span class="nc" id="L401">        return allBookTickerStream(noopCallback, onMessageCallback, noopCallback, noopCallback);</span>
    }

    /**
     * Same as {@link #allBookTickerStream(WebSocketCallback)} plus accepts callbacks for all major websocket connection events.
     *
     * @param onOpenCallback onOpenCallback
     * @param onMessageCallback onMessageCallback
     * @param onClosingCallback onClosingCallback
     * @param onFailureCallback onFailureCallback
     * @return int - Connection ID
     */
    public int allBookTickerStream(WebSocketCallback onOpenCallback, WebSocketCallback onMessageCallback, WebSocketCallback onClosingCallback, WebSocketCallback onFailureCallback) {
<span class="nc" id="L414">        Request request = RequestBuilder.buildWebsocketRequest(String.format(&quot;%s/ws/!bookTicker&quot;, baseUrl));</span>
<span class="nc" id="L415">        return createConnection(onOpenCallback, onMessageCallback, onClosingCallback, onFailureCallback, request);</span>
    }

    /**
     * The Liquidation Order Snapshot Streams push force liquidation order information for specific symbol.
     * For each symbol，only the latest one liquidation order within 1000ms will be pushed as the snapshot.
     * If no liquidation happens in the interval of 1000ms, no stream will be pushed.
     * &lt;br&gt;&lt;br&gt;
     * &amp;lt;symbol&amp;gt;@forceOrder
     * &lt;br&gt;&lt;br&gt;
     * Update Speed: 1000ms
     *
     * @param symbol trading symbol
     * @param onMessageCallback onMessageCallback
     * @return int - Connection ID
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/futures/en/#liquidation-order-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/futures/en/#liquidation-order-streams&lt;/a&gt;
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/delivery/en/#liquidation-order-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/delivery/en/#liquidation-order-streams&lt;/a&gt;
     */
    public int forceOrderStream(String symbol, WebSocketCallback onMessageCallback) {
<span class="nc" id="L436">        ParameterChecker.checkParameterType(symbol, String.class, &quot;symbol&quot;);</span>
<span class="nc" id="L437">        return forceOrderStream(symbol, noopCallback, onMessageCallback, noopCallback, noopCallback);</span>
    }

    /**
     * Same as {@link #forceOrderStream(String, WebSocketCallback)} plus accepts callbacks for all major websocket connection events.
     *
     * @param symbol trading symbol
     * @param onOpenCallback onOpenCallback
     * @param onMessageCallback onMessageCallback
     * @param onClosingCallback onClosingCallback
     * @param onFailureCallback onFailureCallback
     * @return int - Connection ID
     */
    public int forceOrderStream(String symbol, WebSocketCallback onOpenCallback, WebSocketCallback onMessageCallback, WebSocketCallback onClosingCallback, WebSocketCallback onFailureCallback) {
<span class="nc" id="L451">        ParameterChecker.checkParameterType(symbol, String.class, &quot;symbol&quot;);</span>
<span class="nc" id="L452">        Request request = RequestBuilder.buildWebsocketRequest(String.format(&quot;%s/ws/%s@forceOrder&quot;, baseUrl, symbol.toLowerCase()));</span>
<span class="nc" id="L453">        return createConnection(onOpenCallback, onMessageCallback, onClosingCallback, onFailureCallback, request);</span>
    }

    /**
     * The All Liquidation Order Snapshot Streams push force liquidation order information for all symbols in the market.
     * For each symbol，only the latest one liquidation order within 1000ms will be pushed as the snapshot.
     * If no liquidation happens in the interval of 1000ms, no stream will be pushed.
     * &lt;br&gt;&lt;br&gt;
     * !forceOrder@arr
     * &lt;br&gt;&lt;br&gt;
     * Update Speed: 1000ms
     *
     * @param onMessageCallback onMessageCallback
     * @return int - Connection ID
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/futures/en/#all-book-tickers-stream&quot;&gt;
     * https://binance-docs.github.io/apidocs/futures/en/#all-book-tickers-stream&lt;/a&gt;
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/delivery/en/#all-market-liquidation-order-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/delivery/en/#all-market-liquidation-order-streams&lt;/a&gt;
     */
    public int allForceOrderStream(WebSocketCallback onMessageCallback) {
<span class="nc" id="L473">        return allForceOrderStream(noopCallback, onMessageCallback, noopCallback, noopCallback);</span>
    }

    /**
     * Same as {@link #allForceOrderStream(WebSocketCallback)} plus accepts callbacks for all major websocket connection events.
     *
     * @param onOpenCallback onOpenCallback
     * @param onMessageCallback onMessageCallback
     * @param onClosingCallback onClosingCallback
     * @param onFailureCallback onFailureCallback
     * @return int - Connection ID
     */
    public int allForceOrderStream(WebSocketCallback onOpenCallback, WebSocketCallback onMessageCallback, WebSocketCallback onClosingCallback, WebSocketCallback onFailureCallback) {
<span class="nc" id="L486">        Request request = RequestBuilder.buildWebsocketRequest(String.format(&quot;%s/ws/!forceOrder@arr&quot;, baseUrl));</span>
<span class="nc" id="L487">        return createConnection(onOpenCallback, onMessageCallback, onClosingCallback, onFailureCallback, request);</span>
    }

    /**
     * Top bids and asks, Valid are 5, 10, or 20.
     * &lt;br&gt;&lt;br&gt;
     * &amp;lt;symbol&amp;gt;@depth&amp;lt;levels&amp;gt;@&amp;lt;speed&amp;gt;ms
     * &lt;br&gt;&lt;br&gt;
     * Update Speed: 250ms, 500ms or 100ms
     *
     * @param symbol trading symbol
     * @param levels order book depth level, can be 5, 10, or 20
     * @param speed  update speed  in ms, can be 250, 500 or 100
     * @param onMessageCallback onMessageCallback
     * @return int - Connection ID
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/futures/en/#partial-book-depth-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/futures/en/#partial-book-depth-streams&lt;/a&gt;
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/delivery/en/#partial-book-depth-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/delivery/en/#partial-book-depth-streams&lt;/a&gt;
     */
    public int partialDepthStream(String symbol, int levels, int speed, WebSocketCallback onMessageCallback) {
<span class="nc" id="L508">        ParameterChecker.checkParameterType(symbol, String.class, &quot;symbol&quot;);</span>
<span class="nc" id="L509">        return partialDepthStream(symbol, levels, speed, noopCallback, onMessageCallback, noopCallback, noopCallback);</span>
    }

    /**
     * Same as {@link #partialDepthStream(String, int, int, WebSocketCallback)} plus accepts callbacks for all major websocket connection events.
     *
     * @param symbol trading symbol
     * @param levels order book depth level, can be 5, 10, or 20
     * @param speed update speed in ms, can be 250, 500 or 100
     * @param onOpenCallback onOpenCallback
     * @param onMessageCallback onMessageCallback
     * @param onClosingCallback onClosingCallback
     * @param onFailureCallback onFailureCallback
     * @return int - Connection ID
     */
    public int partialDepthStream(String symbol, int levels, int speed, WebSocketCallback onOpenCallback, WebSocketCallback onMessageCallback, WebSocketCallback onClosingCallback, WebSocketCallback onFailureCallback) {
<span class="nc" id="L525">        ParameterChecker.checkParameterType(symbol, String.class, &quot;symbol&quot;);</span>

<span class="nc" id="L527">        Request request = null;</span>
<span class="nc" id="L528">        final int defaultSpeed = 250;</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">        if (speed == defaultSpeed) {</span>
<span class="nc" id="L530">            request = RequestBuilder.buildWebsocketRequest(String.format(&quot;%s/ws/%s@depth%s&quot;, baseUrl, symbol.toLowerCase(), levels));</span>
        } else {
<span class="nc" id="L532">            request = RequestBuilder.buildWebsocketRequest(String.format(&quot;%s/ws/%s@depth%s@%sms&quot;, baseUrl, symbol.toLowerCase(), levels, speed));</span>
        }

<span class="nc" id="L535">        return createConnection(onOpenCallback, onMessageCallback, onClosingCallback, onFailureCallback, request);</span>
    }

    /**
     * Bids and asks, pushed every 250 milliseconds, 500 milliseconds, 100 milliseconds (if existing)
     * &lt;br&gt;&lt;br&gt;
     * &amp;lt;symbol&amp;gt;@depth@&amp;lt;speed&amp;gt;ms
     * &lt;br&gt;&lt;br&gt;
     * Update Speed: 250ms, 500ms, 100ms
     *
     * @param symbol trading symbol
     * @param speed  update speed in ms, can be 250, 500 or 100
     * @param onMessageCallback onMessageCallback
     * @return int - Connection ID
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/futures/en/#diff-book-depth-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/futures/en/#diff-book-depth-streams&lt;/a&gt;
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/delivery/en/#diff-book-depth-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/delivery/en/#diff-book-depth-streams&lt;/a&gt;
     */
    public int diffDepthStream(String symbol, int speed, WebSocketCallback onMessageCallback) {
<span class="nc" id="L555">        ParameterChecker.checkParameterType(symbol, String.class, &quot;symbol&quot;);</span>
<span class="nc" id="L556">        return diffDepthStream(symbol, speed, noopCallback, onMessageCallback, noopCallback, noopCallback);</span>
    }

    /**
     * Same as {@link #diffDepthStream(String, int, WebSocketCallback)} plus accepts callbacks for all major websocket connection events.
     *
     * @param symbol trading symbol
     * @param speed update speed in ms, can be 250, 500 or 100
     * @param onOpenCallback onOpenCallback
     * @param onMessageCallback onMessageCallback
     * @param onClosingCallback onClosingCallback
     * @param onFailureCallback onFailureCallback
     * @return int - Connection ID
     */
    public int diffDepthStream(String symbol, int speed, WebSocketCallback onOpenCallback, WebSocketCallback onMessageCallback, WebSocketCallback onClosingCallback, WebSocketCallback onFailureCallback) {
<span class="nc" id="L571">        ParameterChecker.checkParameterType(symbol, String.class, &quot;symbol&quot;);</span>

<span class="nc" id="L573">        Request request = null;</span>
<span class="nc" id="L574">        final int defaultSpeed = 250;</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">        if (speed == defaultSpeed) {</span>
<span class="nc" id="L576">            request = RequestBuilder.buildWebsocketRequest(String.format(&quot;%s/ws/%s@depth&quot;, baseUrl, symbol.toLowerCase(), speed));</span>
        } else {
<span class="nc" id="L578">            request = RequestBuilder.buildWebsocketRequest(String.format(&quot;%s/ws/%s@depth@%sms&quot;, baseUrl, symbol.toLowerCase(), speed));</span>
        }
<span class="nc" id="L580">        return createConnection(onOpenCallback, onMessageCallback, onClosingCallback, onFailureCallback, request);</span>

    }

     /**
     * User Data Streams are accessed at /ws/&amp;lt;listenKey&amp;gt;
     *
     * @param listenKey listen key
     * @param onMessageCallback onMessageCallback
     * @return int - Connection ID
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/futures/en/#user-data-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/futures/en/#user-data-streams&lt;/a&gt;
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/delivery/en/#user-data-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/delivery/en/#user-data-streams&lt;/a&gt;
     */
    public int listenUserStream(String listenKey, WebSocketCallback onMessageCallback) {
<span class="nc" id="L596">        return listenUserStream(listenKey, noopCallback, onMessageCallback, noopCallback, noopCallback);</span>
    }

    /**
     * Same as {@link #listenUserStream(String, WebSocketCallback)} plus accepts callbacks for all major websocket connection events.
     *
     * @param listenKey listen key
     * @param onOpenCallback onOpenCallback
     * @param onMessageCallback onMessageCallback
     * @param onClosingCallback onClosingCallback
     * @param onFailureCallback onFailureCallback
     * @return int - Connection ID
     */
    public int listenUserStream(String listenKey, WebSocketCallback onOpenCallback, WebSocketCallback onMessageCallback, WebSocketCallback onClosingCallback, WebSocketCallback onFailureCallback) {
<span class="nc" id="L610">        Request request = RequestBuilder.buildWebsocketRequest(String.format(&quot;%s/ws/%s&quot;, baseUrl, listenKey));</span>
<span class="nc" id="L611">        return createConnection(onOpenCallback, onMessageCallback, onClosingCallback, onFailureCallback, request);</span>
    }

    /**
     * Combined streams are accessed at /stream?streams=&amp;lt;streamName1&amp;gt;/&amp;lt;streamName2&amp;gt;/&amp;lt;streamName3&amp;gt;
     *
     * @param streams A list of stream names to be combined &lt;br&gt;
     * @param onMessageCallback onMessageCallback
     * @return int - Connection ID
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/futures/en/#websocket-market-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/futures/en/#websocket-market-streams&lt;/a&gt;
     * @see &lt;a href=&quot;https://binance-docs.github.io/apidocs/delivery/en/#websocket-market-streams&quot;&gt;
     * https://binance-docs.github.io/apidocs/delivery/en/#websocket-market-streams&lt;/a&gt;
     */
    public int combineStreams(ArrayList&lt;String&gt; streams, WebSocketCallback onMessageCallback) {
<span class="nc" id="L626">        return combineStreams(streams, noopCallback, onMessageCallback, noopCallback, noopCallback);</span>
    }

    /**
     * Same as {@link #combineStreams(ArrayList, WebSocketCallback)} plus accepts callbacks for all major websocket connection events.
     *
     * @param streams stream name list
     * @param onOpenCallback onOpenCallback
     * @param onMessageCallback onMessageCallback
     * @param onClosingCallback onClosingCallback
     * @param onFailureCallback onFailureCallback
     * @return int - Connection ID
     */
    public int combineStreams(ArrayList&lt;String&gt; streams, WebSocketCallback onOpenCallback, WebSocketCallback onMessageCallback, WebSocketCallback onClosingCallback, WebSocketCallback onFailureCallback) {
<span class="nc" id="L640">        String url = UrlBuilder.buildStreamUrl(String.format(&quot;%s/stream&quot;, baseUrl), streams);</span>
<span class="nc" id="L641">        Request request = RequestBuilder.buildWebsocketRequest(url);</span>
<span class="nc" id="L642">        return createConnection(onOpenCallback, onMessageCallback, onClosingCallback, onFailureCallback, request);</span>
    }

    /**
     * Closes a specific stream based on stream Id.
     *
     * @param connectionId Connection ID
     */
    public void closeConnection(int connectionId) {
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">        if (connections.containsKey(connectionId)) {</span>
<span class="fc" id="L652">            connections.get(connectionId).close();</span>
<span class="fc" id="L653">            logger.info(&quot;Closing Connection ID {}&quot;, connectionId);</span>
<span class="fc" id="L654">            connections.remove(connectionId);</span>
        } else {
<span class="nc" id="L656">            logger.info(&quot;Connection ID {} does not exist!&quot;, connectionId);</span>
        }
<span class="fc" id="L658">    }</span>

    /**
     * Closes all streams
     */
    public void closeAllConnections() {
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">        if (!connections.isEmpty()) {</span>
<span class="fc" id="L665">            logger.info(&quot;Closing {} connections(s)&quot;, connections.size());</span>
<span class="fc" id="L666">            Iterator&lt;Map.Entry&lt;Integer, WebSocketConnection&gt;&gt; iter = connections.entrySet().iterator();</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L668">                WebSocketConnection connection = iter.next().getValue();</span>
<span class="fc" id="L669">                connection.close();</span>
<span class="fc" id="L670">                iter.remove();</span>
<span class="fc" id="L671">            }</span>
        }

<span class="pc bpc" id="L674" title="1 of 2 branches missed.">        if (connections.isEmpty()) {</span>
<span class="fc" id="L675">            HttpClientSingleton.getHttpClient().dispatcher().executorService().shutdown();</span>
<span class="fc" id="L676">            logger.info(&quot;All connections are closed!&quot;);</span>
        }
<span class="fc" id="L678">    }</span>

    public int createConnection(
            WebSocketCallback onOpenCallback,
            WebSocketCallback onMessageCallback,
            WebSocketCallback onClosingCallback,
            WebSocketCallback onFailureCallback,
            Request request
    ) {
<span class="fc" id="L687">        WebSocketConnection connection = new WebSocketConnection(onOpenCallback, onMessageCallback, onClosingCallback, onFailureCallback, request);</span>
<span class="fc" id="L688">        connection.connect();</span>
<span class="fc" id="L689">        int connectionId = connection.getConnectionId();</span>
<span class="fc" id="L690">        connections.put(connectionId, connection);</span>
<span class="fc" id="L691">        return connectionId;</span>
    }
//     fo the ease of testing the closeAllConnection Methods
    public Map&lt;Integer, WebSocketConnection&gt; getConnections() {
<span class="fc" id="L695">        return  connections;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>